I"÷<p>Recently, I started development of an emacs language mode called <a href="https://github.com/v0dro/rubex-mode-emacs">rubex-mode</a> for supporting Rubex syntax highlighting in emacs. This took me to the <a href="https://www.emacswiki.org/emacs/ModeTutorial">ModeTutorial</a> on the emacs wiki, which is a very detailed tutorial for learning how to write new emacs language modes. Before starting the tutorial I had no knowledge of Emacslisp or writing emacs language modes.</p>

<p>In this post I will share some of the important things that I learned about Emacslisp and some things that I think are important about writing language modes for Emacs.</p>

<h1 id="learning-resources">Learning resources</h1>

<ul>
  <li><a href="https://emacs-doctor.com/learn-emacs-lisp-in-15-minutes.html">Learn emacs lisp in 15 minutes</a></li>
  <li><a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/">Programming in Emacs Lisp</a></li>
  <li><a href="https://emacs.stackexchange.com/questions/715/how-to-know-when-or-when-not-to-use-the-single-quote-before-variable-names">How to know whether to use single quote in elisp.</a></li>
  <li><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Quoting.html">Quote in elisp</a></li>
</ul>

<h1 id="emacs-lisp-basics">Emacs lisp basics</h1>

<h2 id="lisp-evaluation">Lisp evaluation</h2>

<p>If you enable â€˜lisp-interaction-modeâ€™ in emacs you can evaluate lisp using the <code>C-j</code> 
shortcut. That will insert the result of the evaluation in the buffer. <code>C-x C-e</code> 
displays the same result in the minibuffer.</p>

<h2 id="sexps">Sexps</h2>

<p>Programs are made of symbolic expressions (pre-fix notation), like <code>(+ 2 2)</code>, 
this means â€˜2 + 2â€™.</p>

<p>Expressions are made of atomic expressions or more symbolic expressions. In <code>(+ 2 (+ 1 1))</code>, 
1 and 2 are atoms, (+ 2 (+ 1 1)) and (+ 1 1) are symbolic expressions.</p>

<h2 id="getting-and-setting-variables">Getting and setting variables</h2>

<p><code>setq</code> stores a value into a variable:</p>
<div class="language-elisp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>(setq my-name &quot;sameer&quot;)
</pre></td>
</tr></table>
</div>

<p>Variables can also be initialized using <code>defvar</code>. The emacswiki page is <a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/defvar.html">here</a>. 
<code>defvar</code> is similar to <code>setq</code>, but the difference is that <code>defvar</code> will not set the variable 
if it already has a value.</p>

<h2 id="setting-global-constants">Setting global constants</h2>

<p>The <code>defconst</code> keyword is used for setting global constants. It informs a person reading your code that 
symbol has a standard global value, established here, that should not be changed by the user or by other
programs. Note that symbol is not evaluated; the symbol to be defined must appear explicitly in the defconst.</p>

<p>For example:</p>
<pre><code>(defconst pi 3.141592653589793 "The value of Pi.")
</code></pre>
<p>Above code initializes the variable <code>pi</code> to a value and sets a docstring.</p>

<h2 id="functions">Functions</h2>

<p>Functions can be defined using the <code>defun</code> keyword. For example, to defined a function <code>hello</code> that accepts 
an argument <code>name</code> and inserts the variable with a string on the buffer:</p>
<pre><code>(defun hello (name) (insert "Hello " name))
</code></pre>

<p>Fun fact: when evaluating elisp in a buffer, place the cursor at the bottom of the file otherwise emacs will 
only evaluate code until the cursor and throw unexpected output.</p>

<h2 id="combining-expressions">Combining expressions</h2>

<p>You can use the <code>progn</code> form for evaluating a set of expressions one by one and returning the value of the last one. 
The preceding expressions are only evaluated for their side effects and their values are discarded.</p>

<p>All emacs commands are basically just elisp function calls. So you can call something like this:</p>
<pre><code>(progn
  (switch-to-buffer-other-window "*scratch*")
  (hello "you"))
</code></pre>
<p>And it will switch the active window to the <code>*scratch*</code> buffer and print <code>Hello you</code> in the buffer.</p>

<p>A value can be bound to a local variable using <code>let</code>. This command can also be used for combining several sexps.</p>
<pre><code>(let ((local-name "you"))
  (switch-to-buffer-other-window "*test*")
  (erase-buffer)
  (hello local-name))
</code></pre>

<h2 id="quote">Quote</h2>

<p><code>quote</code> is a special form in elisp that returns its single argument, without 
evaluating it. This provides a way to include constants and lists, which are not 
self-evaluating objects, in a program. This <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Quoting.html">link</a> 
talks about it in detail.</p>

<p>Its used so often that a short form of using a single quote is often used instead (<code>'</code>). This 
<a href="https://emacs.stackexchange.com/questions/715/how-to-know-when-or-when-not-to-use-the-single-quote-before-variable-names">answer</a> 
talks in detail about when to and when not to use it.</p>

<p>In general, if you are trying to use the variable itself, use the quoted form, 
otherwise directly use the variable name. For example, in the expression <code>(mapcar 'hello list-of-names)</code>, 
we use a quoted <code>hello</code> because donâ€™t actually want to call the function, we just want to pass a reference 
to it to the <code>mapcar</code> function which will then call <code>hello</code> at its own leisure.</p>

<h2 id="lists">Lists</h2>

<p>A list of names can be stored like so:</p>
<pre><code>(setq list-of-names '("Sarah" "Chloe" "Mathilde"))
</code></pre>

<p>The above expression is quoted because we want to set the whole expression 
as a list to <code>list-of-names</code>.</p>

<p>Use the <code>car</code> function for getting the first element of the list and <code>cdr</code>
for getting all elements except the first element.</p>

<h3 id="cons-cells">Cons cells</h3>

<p>Lists are composed of cons cells. Each cons cell is a tuple of two lisp objects,
the <code>car</code> and <code>cdr</code>. In the case of a list, the first slot of a cons cell holds 
the element of the list and the next part chains to the next element of the list. 
The cdr of the last cell of the list is <code>nil</code>. This helps in detecting the end 
of a list.</p>

<h2 id="dotted-pair-notation">Dotted pair notation</h2>

<p>A dotted pair notation is a general syntax for creating cons cells that represents
the car and cdr explicitly.  In this syntax, <code>(a . b)</code> stands for a cons cell whose 
<code>car</code> is the object <code>a</code> and whose <code>cdr</code> is the object <code>b</code>. Dotted pair notation is 
more general than list syntax because the <code>cdr</code> does not have to be a list.</p>

<p>Dotted pairs can be chained together to form a list. For example, <code>(1 2 3)</code> is written 
as <code>(1 . (2 . (3 . nil)))</code>.</p>

<h1 id="simple-matrix-multplication">Simple matrix multplication</h1>

<h1 id="writing-an-emacs-major-mode">Writing an emacs major mode</h1>

<h2 id="basic-mode-setup">Basic mode setup</h2>

<p>There are certain variables that all modes must define. Hereâ€™s a list:</p>
<ul>
  <li><code>wpdl-mode-hook</code>: allows the user to run their own code when your mode is run.</li>
  <li><code>wpdl-mode-map</code>: allows both you and your users to define their own keymaps.</li>
</ul>

<p>In order to tell emacs that this mode must start when a particular file extension is detected, we add to a list called <code>auto-mode-alist</code> using the <code>add-to-list</code> function. For example:</p>
<pre><code>(add-to-list 'auto-mode-alist '("\\.rubex\\'" . rubex-mode))
</code></pre>

<p>Protip: An <code>alist</code> is for historical reasons made of plain cons cells instead of full lists.</p>

<h2 id="syntax-highlighting">Syntax highlighting</h2>

<h2 id="indentation">Indentation</h2>
:ET