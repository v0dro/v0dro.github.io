
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Setting Up a Lexical Analyser and Parser in Ruby - Travel &lt;code&gt; Music</title>
  <meta name="author" content="Sameer Deshmukh">

  
  <meta name="description" content="I wrote this post as I was setting up the lexer and parser for Rubex, a new superset of Ruby that I’m developing. Let’s demonstrate the basic working &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://v0dro.github.io/blog/2016/08/21/setting-up-a-lexical-analyser-and-parser-in-ruby/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Travel &lt;code&gt; Music" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-55005305-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>



  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [ ['$', '$'], ["\(", "\)"] ],
        displayMath: [ ['$$', '$$'], ["\[", "\]"] ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
      //,
      //displayAlign: "left",
      //displayIndent: "2em"
    });
  </script>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Travel &lt;code&gt; Music</a></h1>
  
    <h2>A place where I share my experiences with Travel, Programming and Music</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="v0dro.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/blog/archives">Archive</a></li>
  <li><a href="/travel">Travel</a></li>
  <li><a href="/code">Code</a></li>
  <li><a href="/music">Music</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Setting Up a Lexical Analyser and Parser in Ruby</h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


<div class="entry-content"><p>I wrote this post as I was setting up the lexer and parser for Rubex, a new superset of Ruby that I’m developing.</p>

<p>Let’s demonstrate the basic working of a lexical analyser and parser in action with a demonstration of a very simple addition program. Before you start, please make sure <a href="https://github.com/ruby/rake">rake</a>, <a href="https://github.com/seattlerb/oedipus_lex">oedipus_lex</a> and <a href="https://github.com/tenderlove/racc">racc</a> are installed on your computer.</p>

<h3 id="configuring-the-lexical-analyser">Configuring the lexical analyser</h3>

<p>The most fundamental need of any parser is that it needs string tokens to work with, which we will provide by way of lexical analysis by using the <a href="https://github.com/seattlerb/oedipus_lex">oedipus_lex</a> gem (the logical successor of <a href="https://github.com/tenderlove/rexical">rexical</a>). Go ahead and create a file <code>lexer.rex</code> with the following code:</p>

<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
</pre></td>
  <td class="code"><pre><span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">AddLexer</span>
macro
  <span style="color:#036;font-weight:bold">DIGIT</span>         <span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#D20">\d</span><span style="color:#808">+</span><span style="color:#404">/</span></span>
rule
  <span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span><span style="color:#036;font-weight:bold">DIGIT</span><span style="font-weight:bold;color:#666">}</span></span><span style="color:#404">/</span></span>    { [<span style="color:#A60">:DIGIT</span>, text.to_i] }
  <span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">.|</span><span style="color:#D20">\n</span><span style="color:#404">/</span></span>        { [text, text] }
inner
  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">do_parse</span>; <span style="color:#080;font-weight:bold">end</span> <span style="color:#777"># this is a stub.</span>
<span style="color:#080;font-weight:bold">end</span> <span style="color:#777"># AddLexer</span>
</pre></td>
</tr></table>
</div>

<p>In the above code, we have defined the lexical analyser using Oedipus Lex’s syntax inside the <code>AddLexer</code> class. Let’s go over each element of the lexer one by one:</p>

<p><strong>macro</strong></p>

<p>The macro keyword lets you define macros for certain regular expressions
that you might need to write repeatedly. In the above lexer, the macro <code>DIGIT</code> is a regular expression (<code>\d+</code>) for detecting one or more integers. We place the regular expression inside forward slashes (<code>/../</code>) because oedipus_lex requires it that way. The lexer can handle any valid Ruby regular expression. See the Ruby docs for details on Ruby regexps.</p>

<p><strong>rule</strong></p>

<p>The section under the <code>rule</code> keyword defines your rules for the lexical analysis. Now it so happens that we’ve defined a macro for detecting digits, and in order to use that macro in the rules, it must be inside a Ruby string interpolation (<code>#{..}</code>). The line to the right of the <code>/#{DIGIT}/</code> states the action that must be taken if such a regular expression is encountered. Thus the lexer will return a Ruby Array that contains the first element as <code>:DIGIT</code>. The second element uses the <code>text</code> variable. This is a reserved variable in lex that holds the text that the lexer has matched. Similar the second rule will match any character (<code>.</code>) or a newline (<code>/n</code>) and return an <code>Array</code> with <code>[text, text]</code> inside it.</p>

<p><strong>inner</strong></p>

<p>Under the <code>inner</code> keyword you can specify any code that you want to occur inside your lexer class. This can be any logic that you want your lexer to execute. The Ruby code under the <code>inner</code> section is copied as-is into the final lexer class. In the above example, we’ve written an empty method called <code>do_parse</code> inside this section. This method is mandatory if you want your lexer to sucessfully execute. We’ll be coupling the lexer with <code>racc</code> shortly, so unless you want to write your own parsing logic, you should leave this method empty.</p>

<h3 id="configuring-the-parser">Configuring the parser</h3>

<p>In order for our addition program to be successful, it needs to know what to do with the tokens that are generated by the lexer. For this purpose, we need <a href="">racc</a>, an LALR(1) parser generator for Ruby. It is similar to yacc or bison and let’s you specify grammars easily.</p>

<p>Go ahead and create a file called <code>parser.racc</code> in the same folder as the previous <code>lexer.rex</code> and <code>Rakefile</code>, and put the following code inside it:</p>

<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
</pre></td>
  <td class="code"><pre><span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">AddParser</span>
rule
  <span style="color:#606">target</span>: exp { result = <span style="color:#00D">0</span> }
  
  <span style="color:#606">exp</span>: exp <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">+</span><span style="color:#710">'</span></span> exp { result += val[<span style="color:#00D">2</span>]; puts result }
     | <span style="color:#036;font-weight:bold">DIGIT</span>
<span style="color:#080;font-weight:bold">end</span>

---- header
require_relative <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">lexer.rex.rb</span><span style="color:#710">'</span></span>

---- inner
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">next_token</span>
  <span style="color:#33B">@lexer</span>.next_token
<span style="color:#080;font-weight:bold">end</span>

<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">prepare_parser</span> file_name
  <span style="color:#33B">@lexer</span> = <span style="color:#036;font-weight:bold">AddLexer</span>.new
  <span style="color:#33B">@lexer</span>.parse_file file_name
<span style="color:#080;font-weight:bold">end</span>
</pre></td>
</tr></table>
</div>

<p>As you can see, we’ve put the logic for the parser inside the <code>AddParser</code> class. Yacc’s <code>$$</code> is the <code>result</code>; <code>$0</code>, <code>$1</code>… is an array called <code>val</code>, and <code>$-1</code>, <code>$-2</code>… is an array called <code>_values</code>. Notice that in racc, only the parsing logic exists inside the class and everything else (i.e under <code>header</code> and <code>inner</code>) exists <em>outside</em> the class. Let’s go over each part of the parser one by one:</p>

<p><strong>class AddParser</strong></p>

<p>This is the core class that contains the parsing logic for the addition parser. Similar to <code>oedipus_lex</code>, it contains a <code>rule</code> section that specifies the grammar. The parser expects tokens in the form of <code>[:TOKEN_NAME, matched_text]</code>. The <code>:TOKEN_NAME</code> must be a symbol. This token name is matched to literal characters in the grammar (<code>DIGIT</code> in the above case). <code>token</code> and <code>expr</code> are varibles. Have a look at <a href="https://en.wikipedia.org/wiki/LALR_parser">this introduction to LALR(1) grammars</a> for further information.</p>

<p><strong>header</strong></p>

<p>The <code>header</code> keyword tells racc what code should be put at the top of the parser that it generates. You usually put your <code>require</code> statements here. In this case, we load the lexer class so that the parser can use it for accessing the tokens generated by the lexer. Notice that <code>header</code> has 4 hyphens (<code>-</code>) and a space before it. This is mandatory if your program is to not malfunction.</p>

<p><strong>inner</strong></p>

<p>The <code>inner</code> keyword tells racc what should be put <em>inside</em> the generated parser class. As you can see there are two methods in the above example - <code>next_token</code> and <code>prepare_parser</code>. The <code>next_token</code> method is mandatory for the parser to function and you must include it in your code. It should contain logic that will return the next token for the parser to consider. Moving on the <code>prepare_parser</code> method, it takes a file name that is to be parsed as an argument (how we pass that argument in will be seen later), and initialzes the lexer. It then calls the <code>parse_file</code> method, which is present in the lexer class by default.</p>

<p>The <code>next_token</code> method in turn uses the <code>@lexer</code> object’s <code>next_token</code> method to get a token generated by the lexer so that it can be used by the parser.</p>

<h3 id="putting-it-all-together">Putting it all together</h3>

<p>Our lexical analyser and parser are now coupled to work with each other, and we now use them in a Ruby program to parse a file. Create a new file called <code>adder.rb</code> and put the following code in it:</p>

<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
</pre></td>
  <td class="code"><pre>require_relative <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">parser.racc.rb</span><span style="color:#710">'</span></span>

file_name = <span style="color:#069">ARGV</span>[<span style="color:#00D">0</span>]
parser = <span style="color:#036;font-weight:bold">AddParser</span>.new
parser.prepare_parser(file_name)
parser.do_parse
</pre></td>
</tr></table>
</div>

<p>The <code>prepare_parser</code> is the same one that was defined in the <code>inner</code> section of the <code>parser.racc</code> above. The <code>do_parse</code> method called on the parser will signal the parser to start doing it’s job.</p>

<p>In a separate file called <code>text.txt</code> put the following text:</p>

<pre><code>2+2
</code></pre>

<p>Oedipus Lex does not have a command line tool like rexical for generating a lexer from the logic specified, but rather has a bunch of rake tasks defined for doing this job.
So now create a <code>Rakefile</code> in the same folder and put this code inside it:</p>

<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
</pre></td>
  <td class="code"><pre>require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">oedipus_lex</span><span style="color:#710">'</span></span>

<span style="color:#036;font-weight:bold">Rake</span>.application.rake_require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">oedipus_lex</span><span style="color:#710">&quot;</span></span>

desc <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Generate Lexer</span><span style="color:#710">&quot;</span></span>
task <span style="color:#A60">:lexer</span>  =&gt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">lexer.rex.rb</span><span style="color:#710">&quot;</span></span>

desc <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Generate Parser</span><span style="color:#710">&quot;</span></span>
task <span style="color:#A60">:parser</span> =&gt; <span style="color:#A60">:lexer</span> <span style="color:#080;font-weight:bold">do</span>
  <span style="background-color:hsla(120,100%,50%,0.06)"><span style="color:#161">`</span><span style="color:#2B2">racc parser.racc -o parser.racc.rb</span><span style="color:#161">`</span></span>
<span style="color:#080;font-weight:bold">end</span>
</pre></td>
</tr></table>
</div>

<p>Running <code>rake parser</code> will generate a two new files - <code>lexer.rex.rb</code> and <code>parser.racc.rb</code> - which will house the classes and logic for the lexer and parser, respectively. You can use your newly written lexer + parser with a <code>ruby adder.rb text.txt</code> command. It should output <code>4</code> as the answer.</p>

<p>You can find all the code in this blogpost <a href="https://github.com/v0dro/scratch/tree/master/lexer_parser">here</a>.</p>
</div>


  <footer>
    <p class="meta">
      
<span class="byline author vcard">Posted by <span class="fn">Sameer Deshmukh</span></span>

      





      


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://v0dro.github.io/blog/2016/08/21/setting-up-a-lexical-analyser-and-parser-in-ruby/" data-via="v0dro" data-counturl="http://v0dro.github.io/blog/2016/08/21/setting-up-a-lexical-analyser-and-parser-in-ruby/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2016/08/16/random-thoughts-on-music-theory/" title="Previous Post: Random thoughts on music theory.">&laquo; Random thoughts on music theory.</a>
      
      
        <a class="basic-alignment right" href="/blog/2016/08/27/advice-for-future-gsoc-students-and-mentors-based-on-my-experience/" title="Next Post: Advice for future GSOC students and mentors based on my experience.">Advice for future GSOC students and mentors based on my experience. &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2017/10/23/explanation-of-exafmm-learning-codes/">Explanation of ExaFMM Learning Codes.</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/11/24/gsoc-2016-wrap-up-for-sciruby/">GSOC 2016 Wrap Up for SciRuby</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/27/advice-for-future-gsoc-students-and-mentors-based-on-my-experience/">Advice for Future GSOC Students and Mentors Based on My Experience.</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/21/setting-up-a-lexical-analyser-and-parser-in-ruby/">Setting Up a Lexical Analyser and Parser in Ruby</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/16/random-thoughts-on-music-theory/">Random Thoughts on Music Theory.</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/v0dro">@v0dro</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'v0dro',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - Sameer Deshmukh -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'v0dro';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://v0dro.github.io/blog/2016/08/21/setting-up-a-lexical-analyser-and-parser-in-ruby/';
        var disqus_url = 'http://v0dro.github.io/blog/2016/08/21/setting-up-a-lexical-analyser-and-parser-in-ruby/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
